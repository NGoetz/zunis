#!/usr/bin/env python3

import random
import os
import sys
import vegas
import math
import torch
import logging
import numpy as np
from inspect import getsourcefile
import numpy as np
from torchps.flat_phase_space_generator import *
from utils.integrands.abstract import Integrand
from utils.integrands import sanitize_variable

logger = logging.getLogger(__name__)

class CrossSection(Integrand):
    """The matrix-element generated by the Fortran-output of MadGraph5_aMC@NLO"""
    
    def __init__(self, e_cm=1000, pdf=False, delr_cut=0.4,pt_cut=10, rap_maxcut=2.4, pdf_type=None, pdf_dir=None, lhapdf_dir=None, process=None, device=None, *args, **kwargs):  
        """

        Parameters
        ----------
        e_cm : float or torch.Tensor
            Centre-of-mass energy of a central two-body collision.
        pdf: boolean
            If True, the beams are assuemed to be proton beams and the PDFs are included in the calculation.
        delr_cut: float or torch.Tensor
            The minimum angular distance between each pair of the outgoing particles. 
        pt_cut: float or torch.Tensor
            The minimal transversal momentum of each outgoing particle.
        rap_maxcut: float or torch.Tensor
            The maximal rapidity of each outgoing particle. -1 means no cut.
        pdf_type: String
            The name of the PDF set to be used by LHAPDF.
        pdf_dir: String
            The directory whre the PDF data sets are stored.
        lhapdf_dir: String
            The path to the LHAPDF shared-object file.
        process: String
            The name given by MadGraph5_aMC@NLO to the subprocess.
        device: torch.device
            Default device where the parameters are stored
        """
        
        logger.debug(process)
        self.pdf=pdf
        self.pdf_obj=None
        
        #Try to import LHAPDF. If this is not possible, PDFs are not included
        if self.pdf and lhapdf_dir==None:
            logger.debug("The directory of the LHAPDF module was not given. PDFs are not included")
            self.pdf=False
        if self.pdf:
            print(lhapdf_dir)
            if lhapdf_dir not in sys.path:
                sys.path.append(lhapdf_dir)
            try:
                import lhapdf
                self.pdf_obj = lhapdf.mkPDF(pdf_type, 0)
            except Exception as e:
                logger.error("LHAPDF could not be imported")
                logger.debug(e)
                self.pdf=False
                
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        
        
        #Try to import the matrix element shared-object file
        if BASE_DIR+"/integrands/mg/"+process not in sys.path:
            sys.path.append(BASE_DIR+"/integrands/mg/"+process)
        try:
            import matrix2py
        except:
            logger.debug("The matrix elements could not be imported")
            
        self.process=process
        self.E_cm=sanitize_variable(e_cm,device)
        self.delR_cut=sanitize_variable(delr_cut,device)
        self.pT_cut=sanitize_variable(pt_cut,device)
        self.rap_maxcut=sanitize_variable(rap_maxcut,device)
        self.default_device=device

        #the mapping between particles and pdg-codes
        names=["d","u","s","c","b","t","g"]
        pdgs=[1,2,3,4,5,6,21]
        
        #the matrix element needs to be initialised
        matrix2py.initialisemodel(BASE_DIR+"/integrands/mg/"+process+"/param/param_card.dat")
        
        #extracting the number of in- and outgoing particles and the masses
        file = open(BASE_DIR+"/integrands/mg/"+process+"/param/nexternal.inc", "r") 
        file.readline()

        n_external=file.readline()
        n_external = int((n_external.split("=")[1]).split(")")[0])
        file.readline()
        n_incoming=file.readline()
        n_incoming = int((n_incoming.split("=")[1]).split(")")[0])
        file.close
        
        file = open(BASE_DIR+"/integrands/mg/"+process+"/param/pmass.inc", "r") 
        z=file.readlines()

        z=[x.split("=")[1].split("\n")[0] for x in z]
        z=[x[::-1].split("(")[0][::-1].split(")")[0] for x in z]
        file.close

        file = open(BASE_DIR+"/integrands/mg/"+process+"/param/param.log", "r")
        p=file.readlines()
        file.close

        masses=[0]*len(z)
        external_masses=[0]*2
        Gf=  float([i for i in p if " mdl_gf " in i][0].split()[7])
        aEW=  1/float([i for i in p if " aewm1 " in i][0].split()[7])
        MZ= float( [i for i in p if " mdl_mz " in i][0].split()[7])
        
        for ider,x in enumerate(z):
            if x=="ZERO":
                masses[ider]=0.0
            elif x=="MDL_MW":
                
                masses[ider]=np.sqrt(MZ**2/2. + np.sqrt(MZ**4/4. - (aEW*np.pi*MZ**2)/(Gf*np.sqrt(2))))
            
            else:
                res = [i for i in p if " "+x.lower()+" " in i][0]
                masses[ider]=float(res.split()[7])
        external_masses[0]=masses[:n_incoming]
        external_masses[1]=masses[n_incoming:]

        #Parsing the involved particles from the process name and mapping on pdg codes
        #pdg code 0 refers to color-neutral particles
        process_name=process.split("P1_")[1]
        particles=process_name.split("_")[0]

        pdg=[0]*len(external_masses[0])
        offset1=0
        offset2=0
        
        for ide,x in enumerate(names):
            ider=ide-offset1-offset2
            marker=particles.find(x)
            
            if marker==0 and (x!='t' or(len(particles)<=2 or (particles[2]!='-' and particles[2]!='+' ))):
                
                pdg[offset1]=pdgs[ider]
                particles=particles[1:]
                
                if len(particles)>0 and particles[0]=="x":
                    pdg[offset1]*=-1
                    particles=particles[1:]
                    
                names.insert(ide,x)
                offset1+=1
            
                
            
            elif marker!=-1 and (x!='t' or(len(particles)<=2+marker or (particles[marker+2]!='p' and particles[marker+2]!='m' ))) :
                particles=particles[:marker]+particles[marker+1 :]
                pdg[1]=pdgs[ider]
                
                if len(particles)>marker and particles[marker]=="x":
                    particles=particles[:marker]+particles[marker+1 :]
                    pdg[1]*=-1
                names.insert(ide,x)
                offset2+=1
            if offset1+offset2==2:
                break
    
        self.pdg=pdg
                

        logger.info("# ingoing particles: "+str(len(external_masses[0])))
        logger.info("Ingoing pdg codes: "+str(pdg[0])+" "+str(pdg[1]))
        logger.info("PDFs active: "+str(self.pdf))
        logger.info("# outgoing particles: "+str(len(external_masses[1])))

        if((len(external_masses[0]))!=2 and self.pdf):
            logger.info("No PDF support for other cases than 2 body collision")
            self.pdf=False
        
        #initialising of the phase space generator
        self.this_process_E_cm = max( self.E_cm, sum(external_masses[1])*2. )
        self.my_ps_generator=FlatInvertiblePhasespace(external_masses[0], external_masses[1],pdf=self.pdf_obj,pdf_active=self.pdf, lhapdf_dir=lhapdf_dir, tau=False)
        
        #determination of the #dof
        if not self.pdf:
            self.d = self.my_ps_generator.nDimPhaseSpace() # number of dimensions
        else:
            self.d = self.my_ps_generator.nDimPhaseSpace()+2 # number of dimensions
            
        super(CrossSection, self).__init__(self.d)


    def evaluate_integrand(self, x):
        #impor the matrix element
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if BASE_DIR+"/integrands/mg/"+self.process not in sys.path:
            sys.path.append(BASE_DIR+"/integrands/mg/"+self.process)
        try:
            import matrix2py
        except:
            logger.error("The matrix elements could not be imported")
            
        #perform the phase-space sampling
        momenta, jac = self.my_ps_generator.generateKinematics_batch(self.this_process_E_cm, x,pT_mincut=self.pT_cut, delR_mincut=self.delR_cut, rap_maxcut=self.rap_maxcut, pdgs=self.pdg)
        #the matrix element can only be calculated on cpu so far
        momenta=momenta.cpu()
        jac=jac.cpu()
        element=[0]*momenta.shape[0]
        #calculate the matrix element for the generated phase space points
        element=[matrix2py.smatrix(momenta[ind,:,:].t().tolist())*jac[ind]
                for ind, q in enumerate(element)]
        
        #conversion in pb
        return torch.tensor(element,device=x.device)/(2.5681894616*10**(-9))
        
    

